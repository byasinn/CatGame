### üìö Como funciona o sistema de **Levels** no CatGame

#### üîÅ Estrutura principal

* A pasta `levels` cont√©m os arquivos de l√≥gica para **cada mundo**, organizados em subpastas como:

  * `level1/`, `level2/`, `level3/`
  * `arcade/` (com l√≥gica pr√≥pria)

* O roteamento principal √© feito no arquivo `levels/level.py`, com a classe `Level`.

---

### üß± Classe `Level`

Level(window, name: str, game_mode: str, player_score: list[int], is_arcade=False, audio=None)


| Par√¢metro      | Significado                                    |
| -------------- | ---------------------------------------------- |
| `window`       | Janela atual (superf√≠cie Pygame)               |
| `name`         | Nome da fase: "Level1", "Level1\_2", etc.      |
| `game_mode`    | Ex: "solo", "cooperative", "competitive"       |
| `player_score` | Lista com pontua√ß√£o dos jogadores              |
| `is_arcade`    | Ativa o modo arcade (ignora algumas cutscenes) |
| `audio`        | Controlador de √°udio do jogo                   |

---

### üìå Funcionamento

1. O nome passado (ex: `"Level1"`) √© mapeado via `PHASE_MAP`:


   PHASE_MAP = {
       "Level1": Level1_0,
       "Level1_2": Level1_2,
       "Level2": Level2,
       "Level3": Level3,
   }


2. O level correspondente √© instanciado:

   self.logic = LevelClass(window, game_mode, player_score, audio)


3. Se for arcade, for√ßa o uso direto de `Level1_2`, sem depender de `PHASE_MAP`.

4. A fun√ß√£o `run()` chama a cutscene inicial (se for "Level1"), executa o level e, se aplic√°vel, faz a transi√ß√£o autom√°tica para o pr√≥ximo:

   if self.name == "Level1" and result:
       run_scene(...)  # cutscene 2
       next_level = Level(..., "Level1_2", ...)
       return next_level.run(...)


